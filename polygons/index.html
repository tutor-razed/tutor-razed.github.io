<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Polygon Drawer - Full Version</title>
<style>
body { margin:0; display:flex; flex-direction:column; align-items:center; font-family:sans-serif; background:#f5f5f5; }
canvas { background:white; border:1px solid #ccc; margin-top:20px; cursor:crosshair; }
#controls { margin-top:10px; }
#controls button, #controls select, #controls input { margin-right:5px; }
#info { margin-top:10px; font-size:16px; }
</style>
</head>
<body>
<h1>Polygon Drawer - Full Version</h1>
<div id="controls">
  <button id="undoBtn">Undo Last Point</button>
  <button id="clearBtn">Clear Canvas</button>
  Units: 
  <select id="unitSelect">
    <option value="mm">mm</option>
    <option value="cm">cm</option>
    <option value="m">m</option>
  </select>
  Show Measurements: <input type="checkbox" id="showMeasurements" checked>
</div>
<canvas id="canvas" width="900" height="600"></canvas>
<div id="info">
Perimeter: <span id="perimeter">0</span> | Area: <span id="area">0</span>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const perimeterDisplay = document.getElementById('perimeter');
const areaDisplay = document.getElementById('area');
const unitSelect = document.getElementById('unitSelect');
const showMeasurementsCheckbox = document.getElementById('showMeasurements');

let points = [];
let shapeClosed = false;
let currentX = 0, currentY = 0;
let drawing = false;
let shiftHeld = false;
let snapRadius = 10;
let scale = 1; // px → measurement
let unit = 'mm';

// --- Units ---
unitSelect.addEventListener('change', ()=>{
  unit = unitSelect.value;
  switch(unit){
    case 'mm': scale=1; break;
    case 'cm': scale=0.1; break;
    case 'm': scale=0.001; break;
  }
  if(shapeClosed){ calculatePerimeter(); calculateArea(); }
  redraw();
});

// --- Show/Hide Measurements ---
showMeasurementsCheckbox.addEventListener('change', ()=>{
  document.getElementById('info').style.display = showMeasurementsCheckbox.checked ? 'block' : 'none';
});

// --- Keyboard ---
window.addEventListener('keydown', e => { if(e.key==='Shift') shiftHeld=true; });
window.addEventListener('keyup', e => { if(e.key==='Shift') shiftHeld=false; });

// --- Buttons ---
document.getElementById('undoBtn').onclick = ()=>{
  if(!shapeClosed && points.length>0){
    points.pop();
    drawing = points.length>0;
    redraw();
  }
};
document.getElementById('clearBtn').onclick = ()=>{
  points=[]; shapeClosed=false; drawing=false; perimeterDisplay.textContent='0'; areaDisplay.textContent='0'; redraw();
};

// --- Drawing Helpers ---
function drawStar(x, y, r=6, color='green'){
  ctx.save();
  ctx.fillStyle = color;
  ctx.beginPath();
  for(let i=0;i<5;i++){
    ctx.lineTo(x + r * Math.cos((18+ i*72) * Math.PI/180),
               y + r * Math.sin((18+ i*72) * Math.PI/180));
    ctx.lineTo(x + (r/2) * Math.cos((54+ i*72) * Math.PI/180),
               y + (r/2) * Math.sin((54+ i*72) * Math.PI/180));
  }
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawVertex(x, y, r=5, color='red'){
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
}

function drawLine(p1,p2){
  ctx.beginPath();
  ctx.moveTo(p1.x,p1.y);
  ctx.lineTo(p2.x,p2.y);
  ctx.strokeStyle='black';
  ctx.lineWidth=2;
  ctx.stroke();
  if(showMeasurementsCheckbox.checked){
    const dx = p2.x-p1.x;
    const dy = p2.y-p1.y;
    const length = Math.round(Math.sqrt(dx*dx + dy*dy)*scale*10)/10;
    const midX=(p1.x+p2.x)/2;
    const midY=(p1.y+p2.y)/2;
    ctx.font='14px Arial';
    ctx.fillStyle='blue';
    ctx.fillText(`${length} ${unit}`, midX+5, midY-5);
  }
}

// --- Perimeter / Area ---
function calculatePerimeter(){
  let perim=0;
  for(let i=0;i<points.length;i++){
    const p1 = points[i];
    const p2 = points[(i+1)%points.length];
    perim += Math.hypot(p2.x-p1.x, p2.y-p1.y) * scale;
  }
  perimeterDisplay.textContent = Math.round(perim*10)/10 + ' ' + unit;
}

function calculateArea(){
  let sum=0;
  for(let i=0;i<points.length;i++){
    const p1 = points[i];
    const p2 = points[(i+1)%points.length];
    sum += (p1.x*p2.y - p2.x*p1.y) * scale * scale;
  }
  areaDisplay.textContent = Math.round(Math.abs(sum/2)*10)/10 + ' ' + unit + '²';
}

// --- Interior Angles ---
function drawAngles(){
  if(!shapeClosed) return;
  for(let i=0;i<points.length;i++){
    const B = points[i];
    const A = points[(i-1+points.length)%points.length];
    const C = points[(i+1)%points.length];
    
    const vBA = {x: A.x - B.x, y: A.y - B.y};
    const vBC = {x: C.x - B.x, y: C.y - B.y};
    
    const dot = vBA.x*vBC.x + vBA.y*vBC.y;
    const magBA = Math.hypot(vBA.x, vBA.y);
    const magBC = Math.hypot(vBC.x, vBC.y);
    const angleRad = Math.acos(dot/(magBA*magBC));
    const angleDeg = Math.round(angleRad*180/Math.PI);
    
    ctx.font='14px Arial';
    ctx.fillStyle='purple';
    ctx.fillText(`${angleDeg}°`, B.x+5, B.y-5);
  }
}

// --- Redraw ---
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let i=1;i<points.length;i++) drawLine(points[i-1], points[i]);
  if(shapeClosed && points.length>2) drawLine(points[points.length-1], points[0]);

  points.forEach(p => drawVertex(p.x,p.y));
  if(points.length>0) drawStar(points[0].x, points[0].y);

  // Phantom line
  if(drawing && !shapeClosed && points.length>0){
    let last = points[points.length-1];
    ctx.strokeStyle='gray';
    ctx.lineWidth=1;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(last.x,last.y);
    ctx.lineTo(currentX,currentY);
    ctx.stroke();
    ctx.setLineDash([]);
    if(showMeasurementsCheckbox.checked){
      const dx=currentX-last.x;
      const dy=currentY-last.y;
      const length = Math.round(Math.sqrt(dx*dx + dy*dy)*scale*10)/10;
      const midX=(last.x+currentX)/2;
      const midY=(last.y+currentY)/2;
      ctx.font='14px Arial';
      ctx.fillStyle='blue';
      ctx.fillText(`${length} ${unit}`, midX+5, midY-5);
    }

    // Alignment guides
    ctx.strokeStyle='orange';
    ctx.lineWidth=1;
    points.forEach(p=>{
      if(currentX === p.x){ ctx.beginPath(); ctx.moveTo(p.x,0); ctx.lineTo(p.x,canvas.height); ctx.stroke(); }
      if(currentY === p.y){ ctx.beginPath(); ctx.moveTo(0,p.y); ctx.lineTo(canvas.width,p.y); ctx.stroke(); }
    });
  }

  drawAngles();
}

// --- Mouse Events ---
canvas.addEventListener('mousedown', e=>{
  if(shapeClosed) return;

  const rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Snap to first vertex if close
  if(points.length>2 && Math.hypot(x-points[0].x, y-points[0].y)<snapRadius){
    x = points[0].x;
    y = points[0].y;
    shapeClosed = true;
    calculatePerimeter();
    calculateArea();
    redraw();
    return;
  }

  // Snap to existing vertices within 2px
  points.forEach(p=>{
    if(Math.abs(x-p.x)<2) x=p.x;
    if(Math.abs(y-p.y)<2) y=p.y;
  });

  // Shift constraint relative to last point
  if(shiftHeld && points.length>0){
    let last = points[points.length-1];
    let dx=x-last.x;
    let dy=y-last.y;
    if(Math.abs(dx)>Math.abs(dy)) y = last.y;
    else x = last.x;
  }

  points.push({x,y});
  drawing = true;
  redraw();
});

canvas.addEventListener('mousemove', e=>{
  if(!drawing || shapeClosed) return;
  const rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Phantom closing
  if(points.length>2 && Math.hypot(x-points[0].x, y-points[0].y)<snapRadius){
    x = points[0].x;
    y = points[0].y;
  }

  // Snap to exact x or y of existing points
  points.forEach(p=>{
    if(Math.abs(x - p.x)<2) x=p.x;
    if(Math.abs(y - p.y)<2) y=p.y;
  });

  // Shift constraint
  if(shiftHeld && points.length>0){
    let last = points[points.length-1];
    let dx=x-last.x;
    let dy=y-last.y;
    if(Math.abs(dx)>Math.abs(dy)) y = last.y;
    else x = last.x;
  }

  currentX = x;
  currentY = y;
  redraw();
});
</script>
</body>
</html>
