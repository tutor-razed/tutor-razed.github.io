<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Letter Countdown</title>

<style>
body {
    font-family: 'Trebuchet MS', sans-serif;
    background: linear-gradient(135deg, #1b1b3a, #0f3460);
    color: #fff;
    text-align: center;
    padding: 20px;
}

.hidden { display: none; }

h1 {
    font-size: 3rem;
    color: #ffcc00;
    text-shadow: 0 0 15px orange;
}

input, select, button {
    font-size: 1.1rem;
    padding: 10px;
    margin: 6px;
    border-radius: 6px;
    border: none;
}

button {
    cursor: pointer;
    background: linear-gradient(to bottom, #ff9800, #ff5722);
    color: #000;
    font-weight: bold;
}
button:hover { transform: scale(1.05); }

#puzzle {
    font-size: 2.3rem;
    letter-spacing: 6px;
    margin: 25px;
    line-height: 3.2rem;
}

.word-gap { margin-right: 30px; }

.punctuation {
    color: #00ffff;
    font-weight: bold;
}

.keyboard {
    max-width: 720px;
    margin: 20px auto;
}
.keyboard button {
    width: 48px;
    height: 48px;
    margin: 5px;
    font-weight: bold;
    font-size: 1.1rem;
}

.correct {
    background: linear-gradient(#00ff99, #00cc66) !important;
}
.wrong {
    background: linear-gradient(#ff0033, #990000) !important;
    color: white;
}

#fuse-container {
    width: 320px;
    height: 22px;
    border-radius: 12px;
    border: 3px solid #fff;
    margin: 20px auto;
    background: #333;
    overflow: hidden;
}

#fuse {
    height: 100%;
    background: linear-gradient(90deg, yellow, orange, red);
    width: 100%;
    animation: flicker 0.5s infinite alternate;
    transition: width 0.4s linear;
}

@keyframes flicker {
    from { filter: brightness(1); }
    to { filter: brightness(1.3); }
}

#bomb {
    font-size: 5rem;
    animation: shake 0.6s infinite;
}

@keyframes shake {
    0% { transform: rotate(0deg); }
    25% { transform: rotate(-3deg); }
    50% { transform: rotate(3deg); }
    75% { transform: rotate(-3deg); }
    100% { transform: rotate(0deg); }
}

/* BOOM */
#boomScreen {
    animation: flashRed 0.4s infinite alternate;
}
@keyframes flashRed {
    from { background: black; }
    to { background: darkred; }
}
#boom {
    font-size: 6rem;
    color: yellow;
    text-shadow: 0 0 30px red;
}

/* WIN */
#winScreen {
    animation: flashGreen 0.4s infinite alternate;
}
@keyframes flashGreen {
    from { background: #003300; }
    to { background: #006600; }
}
#win {
    font-size: 5rem;
    color: #00ffcc;
    text-shadow: 0 0 25px gold;
}

#error {
    color: #ff6666;
    font-weight: bold;
}
</style>
</head>

<body>

<h1>üí£ LETTER COUNTDOWN üí£</h1>

<div id="setup">
    <h2>Player A: Enter Secret Phrase</h2>

    <hr style="max-width:720px; margin:20px auto; opacity:.3;">
    <h3>Online Play</h3>
    <input id="roomCode" placeholder="Room code (or use invite link)">
    <button type="button" id="createRoomBtn">Create Room</button>
    <button type="button" id="joinRoomBtn">Join Room</button>
    <div id="onlineInfo"></div>

    <br>

    <input type="password" id="secretInput" placeholder="Letters only (min 5)" list="phraseSuggestions">
    <datalist id="phraseSuggestions"></datalist>
    <br>
    <button type="button" id="randomPhraseBtn">üé≤ Random phrase</button>
    <button type="button" id="nextPhraseBtn">‚û°Ô∏è Next phrase</button>

    <br>
    <label><input type="checkbox" id="toggleView"> Show phrase</label>
    <br>
    <label>Wrong guesses allowed:</label>
    <select id="maxWrong">
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="15">15</option>
        <option value="26">26</option>
    </select>
    <br>
    <button onclick="startGame()">üöÄ Start Game</button>
    <div id="error"></div>
</div>

<div id="game" class="hidden">
    <div id="fuse-container"><div id="fuse"></div></div>
    <div id="bomb">üí£</div>
    <div id="puzzle"></div>
    <div class="keyboard" id="keyboard"></div>
    <button onclick="resetGame()">üîÅ Reset Game</button>
</div>

<div id="boomScreen" class="hidden">
    <div id="boom">üí• BOOM üí•</div>
    <p>The phrase was:</p>
    <h2 id="boomPhrase"></h2>
    <button onclick="resetGame()">‚ñ∂ PLAY AGAIN</button>
</div>

<div id="winScreen" class="hidden">
    <div id="win">üéâ YOU SAVED THE BOMB üéâ</div>
    <p>The phrase was:</p>
    <h2 id="winPhrase"></h2>
    <button onclick="resetGame()">‚ñ∂ PLAY AGAIN</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>

let phrase = "";
let guessed = [];
let wrong = 0;
let maxWrong = 5;
let letterButtons = {};
const allowedPunctuation = [".", ",", "?", "!", "'"];

// Phrase bank for students (edit freely)
const PHRASE_BANK = [
  "CAT",
  "DOG",
  "RED BOAT",
  "BIG TREE",
  "I CAN DO IT",
  "WE ARE FRIENDS",
  "LET'S GO",
  "DON'T STOP",
  "READ A BOOK",
  "PACK A LUNCH"
];

let phraseIndex = 0;
function pickRandomPhrase(){ return PHRASE_BANK[Math.floor(Math.random() * PHRASE_BANK.length)]; }
function pickNextPhrase(){
  const p = PHRASE_BANK[phraseIndex % PHRASE_BANK.length];
  phraseIndex++;
  return p;
}
function populateSuggestions(){
  const dl = document.getElementById("phraseSuggestions");
  if (!dl) return;
  dl.innerHTML = PHRASE_BANK.map(p => `<option value="${p}"></option>`).join("");
}

// --- Supabase Online Mode ---
const SUPABASE_URL = "https://deccrfwqzkgxsitlmtzm.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_Y9-YxPTzK-J3EWHY0Sw6ww_AltcM95-";
const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let online = {
  enabled: false,
  roomId: null,
  userId: null,
  isHost: false,
  roomSub: null,
  guessSub: null,
  secretLocal: null, // host keeps secret locally too (and can reload from room_secrets)
};

function uiInfo(msg){
  const el = document.getElementById("onlineInfo");
  if (el) el.textContent = msg || "";
}

function makeRoomId(len=5){
  const chars="ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let s=""; for(let i=0;i<len;i++) s+=chars[Math.floor(Math.random()*chars.length)];
  return s;
}

function roomLink(roomId){
  return `${location.origin}${location.pathname}?room=${encodeURIComponent(roomId)}`;
}

function buildInitialMask(secretUpper){
  let out = "";
  for (const c of secretUpper){
    if (c >= "A" && c <= "Z") out += "_";
    else if (c === " ") out += " ";
    else if (allowedPunctuation.includes(c)) out += c;
    else out += "_";
  }
  return out;
}

function applyGuessToMask(mask, secretUpper, letter){
  let arr = mask.split("");
  for (let i=0;i<secretUpper.length;i++){
    if (secretUpper[i] === letter) arr[i] = letter;
  }
  return arr.join("");
}

async function loadHostSecretIfNeeded(){
  if (!online.isHost || !online.roomId) return;
  if (online.secretLocal) return;

  const { data, error } = await sb.from("room_secrets").select("secret").eq("room_id", online.roomId).maybeSingle();
  if (!error && data && data.secret){
    online.secretLocal = data.secret;
    phrase = data.secret; // keep host UI aligned
  }
}

async function initOnline(){
  const { data, error } = await sb.auth.signInAnonymously();
  if (error) {
    uiInfo("Supabase auth error: " + error.message);
    return;
  }
  online.userId = data.user.id;

  // Auto-join via invite link
  const params = new URLSearchParams(location.search);
  const room = params.get("room");
  if (room){
    document.getElementById("roomCode").value = room.toUpperCase();
    await joinRoom(room.toUpperCase());
  }
}

// ---- UI events (local only) ----
document.getElementById("toggleView").addEventListener("change", e => {
  document.getElementById("secretInput").type = e.target.checked ? "text" : "password";
});
document.getElementById("randomPhraseBtn").addEventListener("click", () => {
  document.getElementById("secretInput").value = pickRandomPhrase();
  document.getElementById("secretInput").focus();
});
document.getElementById("nextPhraseBtn").addEventListener("click", () => {
  document.getElementById("secretInput").value = pickNextPhrase();
  document.getElementById("secretInput").focus();
});

// Keyboard typing support
document.addEventListener("keydown", e => {
  if (!document.getElementById("game").classList.contains("hidden")) {
    let key = e.key.toUpperCase();
    if (key >= "A" && key <= "Z" && letterButtons[key] && !letterButtons[key].disabled) {
      guess(key, letterButtons[key]);
    }
  }
});

populateSuggestions();
initOnline();

document.getElementById("createRoomBtn").addEventListener("click", async () => {
  if (!online.userId) return uiInfo("Not signed in yet‚Ä¶ try again in a second.");
  const id = makeRoomId();
  const allowed_wrong = parseInt(document.getElementById("maxWrong").value, 10);

  const { error } = await sb.from("rooms").insert({
    id,
    host_user: online.userId,
    status: "waiting",
    allowed_wrong,
    wrong: 0,
    guessed: [],
    mask: "",
    reveal: null
  });

  if (error){
    uiInfo("Create room failed: " + error.message);
    return;
  }

  online.enabled = true;
  online.roomId = id;
  online.isHost = true;

  uiInfo("Room created. Share link: " + roomLink(id));
  await subscribeRoom(id);
});

document.getElementById("joinRoomBtn").addEventListener("click", async () => {
  const id = document.getElementById("roomCode").value.trim().toUpperCase();
  if (!id) return uiInfo("Enter a room code.");
  await joinRoom(id);
});

async function joinRoom(id){
  if (!online.userId) return uiInfo("Not signed in yet‚Ä¶ try again in a second.");

  const { data: room, error } = await sb.from("rooms").select("*").eq("id", id).single();
  if (error) return uiInfo("Join failed: " + error.message);

  // Claim guest slot if empty and you're not the host
  if (room.guest_user == null && room.host_user !== online.userId){
    const { error: upErr } = await sb.from("rooms")
      .update({ guest_user: online.userId })
      .eq("id", id)
      .eq("guest_user", null);
    if (upErr) console.warn(upErr);
  }

  online.enabled = true;
  online.roomId = id;

  const { data: room2 } = await sb.from("rooms").select("*").eq("id", id).single();
  online.isHost = (room2.host_user === online.userId);

  uiInfo(`Joined room ${id}. You are ${online.isHost ? "Host" : "Guest"}.`);
  await subscribeRoom(id);
  await loadHostSecretIfNeeded();
}

async function subscribeRoom(roomId){
  if (online.roomSub) await sb.removeChannel(online.roomSub);
  online.roomSub = sb.channel("room:"+roomId)
    .on("postgres_changes",
      { event: "*", schema: "public", table: "rooms", filter: `id=eq.${roomId}` },
      (payload) => onRoomUpdate(payload.new)
    )
    .subscribe();

  // Host subscribes to guesses to process them
  if (online.isHost){
    await loadHostSecretIfNeeded();

    if (online.guessSub) await sb.removeChannel(online.guessSub);
    online.guessSub = sb.channel("guesses:"+roomId)
      .on("postgres_changes",
        { event: "INSERT", schema: "public", table: "room_guesses", filter: `room_id=eq.${roomId}` },
        (payload) => onGuessEvent(payload.new)
      )
      .subscribe();
  }
}

function hideAll() {
  ["setup","game","boomScreen","winScreen"].forEach(id =>
    document.getElementById(id).classList.add("hidden")
  );
}

function drawPuzzleOnline(maskOrPhrase){
  let html = "";
  for (let char of maskOrPhrase) {
    if (char === " ") html += `<span class="word-gap"></span>`;
    else if (allowedPunctuation.includes(char)) html += `<span class="punctuation">${char}</span> `;
    else if (char >= "A" && char <= "Z") html += char + " ";
    else if (char === "_") html += "_ ";
    else html += "_ ";
  }
  document.getElementById("puzzle").innerHTML = html;
}

function renderKeyboardState(){
  // Rebuild keyboard and apply correct/wrong classes based on current state.
  drawKeyboard();

  // In online mode, guests infer correctness from mask (revealed letters exist in mask)
  // Host can use phrase directly.
  const reference = online.enabled
    ? (online.isHost ? phrase : (phrase || ""))  // guest: phrase holds mask during play
    : phrase;

  Object.keys(letterButtons).forEach(letter => {
    const btn = letterButtons[letter];
    if (!btn) return;

    if (guessed.includes(letter)){
      btn.disabled = true;

      // correct if it appears in reference display (mask contains the letter or host phrase contains)
      const isCorrect = reference.includes(letter);
      btn.classList.add(isCorrect ? "correct" : "wrong");
    }
  });
}

function onRoomUpdate(room){
  maxWrong = room.allowed_wrong;
  wrong = room.wrong;
  guessed = room.guessed || [];

  // Guest never sees secret; during play we store mask in `phrase` for rendering.
  if (!online.isHost){
    phrase = room.mask || "";
  } else {
    // Host: try to ensure phrase/secretLocal is available after refresh
    if (!online.secretLocal && room.status !== "waiting") {
      loadHostSecretIfNeeded();
    }
  }

  if (room.status === "waiting"){
    hideAll();
    document.getElementById("setup").classList.remove("hidden");
    return;
  }

  if (room.status === "playing"){
    hideAll();
    document.getElementById("game").classList.remove("hidden");

    const display = online.isHost ? phrase : (room.mask || "");
    drawPuzzleOnline(display);
    renderKeyboardState();
    updateFuse();
    return;
  }

  if (room.status === "ended"){
    const revealedPhrase = online.isHost ? (phrase || online.secretLocal || "") : (room.reveal || room.mask || "");

    const didWin = room.mask && !room.mask.includes("_");
    const didLose = room.wrong >= room.allowed_wrong;

    hideAll();
    if (didLose){
      document.getElementById("boomScreen").classList.remove("hidden");
      document.getElementById("boomPhrase").textContent = revealedPhrase;
    } else if (didWin){
      document.getElementById("winScreen").classList.remove("hidden");
      document.getElementById("winPhrase").textContent = revealedPhrase;
    } else {
      // fallback
      document.getElementById("game").classList.remove("hidden");
      drawPuzzleOnline(room.mask || "");
      renderKeyboardState();
      updateFuse();
    }
  }
}

function drawPuzzle() {
  let html = "";
  for (let char of phrase) {
    if (char === " ") html += `<span class="word-gap"></span>`;
    else if (allowedPunctuation.includes(char)) html += `<span class="punctuation">${char}</span> `;
    else if (guessed.includes(char)) html += char + " ";
    else html += "_ ";
  }
  document.getElementById("puzzle").innerHTML = html;
}

function drawKeyboard() {
  const kb = document.getElementById("keyboard");
  kb.innerHTML = "";
  letterButtons = {};

  const rows = [
    ["Q","W","E","R","T","Y","U","I","O","P"],
    ["A","S","D","F","G","H","J","K","L"],
    ["Z","X","C","V","B","N","M"]
  ];

  rows.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.style.display = "flex";
    rowDiv.style.justifyContent = "center";
    rowDiv.style.flexWrap = "wrap";
    rowDiv.style.gap = "5px";
    rowDiv.style.marginBottom = "6px";

    row.forEach(letter => {
      let btn = document.createElement("button");
      btn.textContent = letter;
      btn.onclick = () => guess(letter, btn);
      rowDiv.appendChild(btn);
      letterButtons[letter] = btn;
    });

    kb.appendChild(rowDiv);
  });
}

function updateFuse() {
  let percent = ((maxWrong - wrong) / maxWrong) * 100;
  document.getElementById("fuse").style.width = Math.max(0, percent) + "%";
}

function checkEnd() {
  if (wrong >= maxWrong) {
    hideAll();
    document.getElementById("boomScreen").classList.remove("hidden");
    document.getElementById("boomPhrase").textContent = phrase;
  } else if (
    phrase.split("").every(c =>
      c === " " ||
      allowedPunctuation.includes(c) ||
      guessed.includes(c)
    )
  ) {
    hideAll();
    document.getElementById("winScreen").classList.remove("hidden");
    document.getElementById("winPhrase").textContent = phrase;
  }
}

async function startGame() {
  const input = document.getElementById("secretInput").value.toUpperCase();
  const error = document.getElementById("error");
  error.textContent = "";

  // Validate characters
  for (let c of input) {
    if (
      !(c >= "A" && c <= "Z") &&
      c !== " " &&
      !allowedPunctuation.includes(c)
    ) {
      error.textContent = "Only letters, spaces, and . , ? ! ' are allowed.";
      return;
    }
  }

  // Count letters only
  const letterCount = input.split("").filter(c => c >= "A" && c <= "Z").length;
  if (letterCount < 5) {
    error.textContent = "Phrase must contain at least 5 letters.";
    return;
  }

  phrase = input;
  guessed = [];
  wrong = 0;
  maxWrong = parseInt(document.getElementById("maxWrong").value);

  // ONLINE: host starts the round
  if (online.enabled){
    if (!online.isHost){
      error.textContent = "Only the host can start the game in online mode.";
      return;
    }

    online.secretLocal = input;

    const mask = buildInitialMask(input);

    // save secret to host-only table
    const up1 = await sb.from("room_secrets").upsert({ room_id: online.roomId, secret: input });
    if (up1.error){
      error.textContent = "Failed to save secret: " + up1.error.message;
      return;
    }

    // publish public state
    const up2 = await sb.from("rooms").update({
      status: "playing",
      allowed_wrong: maxWrong,
      wrong: 0,
      guessed: [],
      mask,
      reveal: null
    }).eq("id", online.roomId);

    if (up2.error){
      error.textContent = "Failed to start room: " + up2.error.message;
      return;
    }

    // Let realtime drive the UI
    return;
  }

  // LOCAL mode
  hideAll();
  document.getElementById("game").classList.remove("hidden");
  drawPuzzle();
  drawKeyboard();
  updateFuse();
}

async function guess(letter, btn) {
  // ONLINE: send guess event; host processes and updates room
  if (online.enabled){
    btn.disabled = true;

    const { error } = await sb.from("room_guesses").insert({
      room_id: online.roomId,
      user_id: online.userId,
      letter
    });

    if (error){
      console.warn(error);
      btn.disabled = false;
    }
    return;
  }

  // LOCAL mode
  btn.disabled = true;
  if (phrase.includes(letter)) {
    if (!guessed.includes(letter)) guessed.push(letter);
    btn.classList.add("correct");
  } else {
    wrong++;
    btn.classList.add("wrong");
    updateFuse();
  }
  drawPuzzle();
  checkEnd();
}

async function onGuessEvent(ev){
  if (!online.isHost) return;

  // Make sure host has secret (important after refresh)
  if (!online.secretLocal) {
    await loadHostSecretIfNeeded();
  }
  const secret = online.secretLocal;
  if (!secret) return;

  const { data: room, error } = await sb.from("rooms").select("*").eq("id", online.roomId).single();
  if (error || !room) return;

  const letter = (ev.letter || "").toUpperCase();
  if (!(letter >= "A" && letter <= "Z")) return;

  const currentGuessed = room.guessed || [];
  if (currentGuessed.includes(letter)) return;

  const guessed2 = [...currentGuessed, letter];
  let wrong2 = room.wrong;
  let mask2 = room.mask;

  if (secret.includes(letter)){
    mask2 = applyGuessToMask(mask2, secret, letter);
  } else {
    wrong2 = wrong2 + 1;
  }

  const endedByWrong = wrong2 >= room.allowed_wrong;
  const endedByWin = !mask2.includes("_");
  const status2 = (endedByWrong || endedByWin) ? "ended" : "playing";

  await sb.from("rooms").update({
    guessed: guessed2,
    wrong: wrong2,
    mask: mask2,
    status: status2,
    reveal: (status2 === "ended") ? secret : null
  }).eq("id", online.roomId);
}

function resetGame() {
  phrase = "";
  guessed = [];
  wrong = 0;
  online.secretLocal = online.secretLocal; // keep host secret in memory until next round if you want

  document.getElementById("secretInput").value = "";
  document.getElementById("error").textContent = "";

  hideAll();
  document.getElementById("setup").classList.remove("hidden");
}
</script>
</body>
</html>
